#Circlize introduction

Circular layout is very useful to represent complicated information, especially for genomic data. It
has advantages to visualize data with long axes or large amount of categories, described with different
measurements. It is also effective to visualize relations between elements.
Circos (http://circos.ca) is an extraordinarily cool tool to make such circular layout and it is
broadly used in real applications, not just popular in Genomic but in a lot of other areas as well. It
is not only a way to visualize data, but also enhances the representation of scientific results into a
level of aesthetics. Therefore, most people call figures with circular layout as ‘circos plot’. Here the
circlize package 1 aims to implement Circos in R. One important advantage for the implementation
in R is that R is an ideal environment which provides seamless connection between data analysis and
data visualization. This package is not a front-end wrapper to generate configuration files for Circos,
but completely coded in R style by using R’s elegant statistical and graphic engine. We aim to keep
the flexibility and configurability of Circos, also make the package more straightforward to use and
enhance it to support more types of graphics.
1 Principle of design
Since most of the figures are composed of simple graphics, such as points, lines, polygon (for filled
colors) et al, circlize implements low-level graphic functions for adding graphics in circular layout, so
that more higher level graphics can be easily comprised by low-level graphics. This principle ensures
the generality that types of high-level graphics are not restricted by the software but determined by
users.
Currently there are following graphic functions that can be used for plotting, they are similar to
the functions without “circos.” prefix from the traditional graphic engine (you can also see the
correspondence in figure 1):
• circos.points: add points in a cell, similar as points.
• circos.lines: add lines in a cell, similar as lines.
• circos.rect: add rectangle in a cell, similar as rect.
• circos.polygon: add polygon in a cell, similar as polygon.
• circos.text: add text in a cell, similar as text.
• circos.axis: add axis in a cell, functionally similar as axis but with more features.
• circos.link: this maybe the unique feature for circular layout to represent relationships between
elements.
For adding points, lines and text in cells through the whole track (among several sectors), the
following functions are available:
• circos.trackPoints: this can be replaced by circos.points through a for loop.
• circos.trackLines: this can be replaced by circos.lines through a for loop.

It would be great if you can cite: Gu Z et. al. (2014) circlize implements and enhances circular visualization in R. Bioinformatics.

circos.trackPlotRegion ->  plot.default
circos.points  -> points
circos.lines -> lines
circos.text -> text
circos.rect -> rect
circos.polygon -> polygon
circos.axis -> axis



• circos.trackText: this can be replaced by circos.text through a for loop.
Functions to arrange the circular layout:
• circos.trackPlotRegion: create plotting regions for cells in a track.
• circos.updatePlotRegion: update an existed cell.
• circos.par: graphic parameters.
• circos.info: print general parameters of current circos plot.
• circos.clear: reset graphic parameters and internal variables.

Theoretically, you are able to draw most kinds of circos figures by the above functions. As you will
see, all the figures which are ‘round’ in the six vignettes are all generated by circlize package.
The following part of this vignette is structured as follows: First there is an example to give a quick
glance of how to implement a circular layout by circlize. Then we introduce the basic principle (or the
order of using the circos functions) for plotting. After that there are detailed explanations of graphic
parameters, coordinates transformation and usage of low-level functions. Finally we introduce some
tricks for making more complicated circos plots.

# A quick glance

Following is an example to show the basic feature and usage of circlize package. First let’s generate
some random data. There needs a factor to represent categories, values on x-axis, and values on y-axis.
set.seed(999)
n = 1000
a = data.frame(factor = sample(letters[1:8], n, replace = TRUE),
x = rnorm(n), y = runif(n))
First initialize the layout. In this step, circos.initialize allocates sectors in the circle according
to ranges of x-values in different categories. E.g, if there are two categories, range for x-values in the
first category is c(0, 2) and range for x-values in the second category is c(0, 1), the first category
would hold approximately 67% areas of the circle. Here we only need x-values because all cells in a
sector share the same x-ranges.
We explicitly set par(mar) because the default graphic device has equal values of width and height,
we set the figure margins to a same value to make sure the plot that we make is a real circle.
library(circlize)
par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.7)
circos.par("track.height" = 0.1)
circos.initialize(factors = a$factor, x = a$x)
Draw the first track (figure 2 A). Before drawing any track we need to know that all tracks should
firstly be created by circos.trackPlotRegion, then those low-level functions can be applied (recall in
traditional R graphic engine, you need first call plot.default and then you can use functions such as
points and lines to add graphics on it). Since x-lims for cells in the track have already been defined
in the initialization step, here we only need to specify the y-lim for each cell, either by y or ylim
argument.
We also add axes in the first track, The axis for each cell is added by panel.fun argument.
circos.trackPlotRegion creates plotting region cell by cell and the panel.fun is actually executed
immediately after the creation of the plotting region for a certain cell. So panel.fun actually means
adding graphics in the “current cell”. After that, we add points through the whole track by circos.trackPoints.
Finally, add two texts in a certain cell (the cell is specified by sector.index and track.index argument).
When adding the second text, we do not specify track.index because the package knows we
are now in the first track.
Here what should be noted is that the first track has a index number of 1. An internal variable
which traces the tracks would set the ‘current track index’ to 1. So if the track index is not specified


in the plotting functions such as circos.trackPoints and circos.text which are called after the
creation of the track, the current track index would be used as the default track index. (Details will be
explained in the following sections).
circos.trackPlotRegion(factors = a$factor, y = a$y,
panel.fun = function(x, y) {
circos.axis()
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(a$factor, a$x, a$y, col = col, pch = 16, cex = 0.5)
circos.text(-1, 0.5, "left", sector.index = "a", track.index = 1)
circos.text(1, 0.5, "right", sector.index = "a")
Draw the second track (figure 2 B).We use circos.trackHist to add histograms in the track. The
function also creates a new track because drawing histogram is really high level, so we do not need to
call circos.trackPlotRegion here. The index for this track is 2.
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)
Draw the third track (figure 2 C). Here some meta data for the current cell can be obtained by
get.cell.meta.data. This function needs sector.index and track.index arguments, and if they are
not specified, it means it is the current sector index and the current track index.
circos.trackPlotRegion(factors = a$factor, x = a$x, y = a$y,
panel.fun = function(x, y) {
grey = c("#FFFFFF", "#CCCCCC", "#999999")
sector.index = get.cell.meta.data("sector.index")
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), mean(ylim), sector.index)
circos.points(x[1:10], y[1:10], col = "red", pch = 16, cex = 0.6)
circos.points(x[11:20], y[11:20], col = "blue", cex = 0.6)
})
You can update an existed cell by specifying sector.index and track.index in circos.updatePlotRegion.
The function erases graphics which have been added. Here we erase graphics in one cell in track 2,
sector d and re-add some points (figure 2 D). circos.updatePlotRegion can not modify the xlim and
ylim of the cell as well as other settings related to the position of the cell. circos.updatePlotRegion
will modify current sector index and track index.
circos.updatePlotRegion(sector.index = "d", track.index = 2)
circos.points(x = -2:2, y = rep(0, 5))
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
circos.text(mean(xlim), mean(ylim), "updated")
Draw the fourth track (figure 2 E). Here you can choose different line types which is similar as
type argument in lines.
circos.trackPlotRegion(factors = a$factor, y = a$y)
circos.trackLines(a$factor[1:100], a$x[1:100], a$y[1:100], type = "h")
Draw links (figure 2 F). Links can be from point to point, point to interval or interval to interval.
Some of the arguments will be explained in the following sections.
circos.link("a", 0, "b", 0, h = 0.4)
circos.link("c", c(-0.5, 0.5), "d", c(-0.5,0.5), col = "red",
border = "blue", h = 0.2)
circos.link("e", 0, "g", c(-1,1), col = "green", lwd = 2, lty = 2)

## get info
You can get a summary of your circular layout by circos.info.
circos.info()
circos.info(sector.index = "a", track.index = 2)
Finally we need to reset the graphic parameters and internal variables, so that it will not mess up
your next plot.
circos.clear()